# dstack VM Integrity Verification

## Overview

To ensure that a VM is running a specific image, dstack uses a TEE (Trusted Execution Environment) attestation system based on Intel TDX with verifiable cryptographic measurements.

## Verification Process

### 1. Obtain Attestation (Quote) from VM

The VM can generate an attestation via the Guest Agent:

```rust
use platform_engine_executor::vmm_client::VmmClient;
use dstack_vmm_rpc::{Id, StatusRequest};

// Get VM info via VMM
let vmm_client = VmmClient::new("http://127.0.0.1:11530".to_string());
let status = vmm_client.status(StatusRequest {
    ids: vec![],
    brief: false,
    keyword: String::new(),
    page: 0,
    page_size: 10,
}).await?;

// For each VM, obtain an attestation
for vm in status.vms {
    // Via VM Guest Agent (port 8090)
    let quote_response = get_quote_from_vm(&vm.app_url).await?;
    verify_vm_integrity(&quote_response).await?;
}
```

### 2. Attestation Structure

An attestation (quote) contains:

- **MRTD**: Virtual firmware measurement (OVMF)
- **RTMR0**: Hardware configuration (CPU, memory, devices)
- **RTMR1**: Linux kernel measurement
- **RTMR2**: Kernel cmdline + rootfs hash + initrd
- **RTMR3**: Compose hash + instance ID + app ID + key provider
- **event_log**: Event log with boot details
- **os_image_hash**: Hash of the OS image used

### 3. Attestation Verification

The process in 3 steps:

#### Step 1: Verify Quote Signature

Use `dcap-qvl` to verify that the quote was generated by a legitimate TDX environment:

```rust
use dcap_qvl::collateral::get_collateral_and_verify;

let verified_attestation = get_collateral_and_verify(&quote, pccs_url).await?;
```

#### Step 2: Verify OS Image Measurements

Compare MRTD, RTMR0, RTMR1, RTMR2 with pre-calculated image measurements:

```rust
// Expected measurements from image (calculated during build)
let expected_mrs = Mrs {
    mrtd: expected_mrtd,
    rtmr0: expected_rtmr0,
    rtmr1: expected_rtmr1,
    rtmr2: expected_rtmr2,
};

// Verify that measurements match
assert_eq!(verified_mrs.mrtd, expected_mrs.mrtd);
assert_eq!(verified_mrs.rtmr0, expected_mrs.rtmr0);
assert_eq!(verified_mrs.rtmr1, expected_mrs.rtmr1);
assert_eq!(verified_mrs.rtmr2, expected_mrs.rtmr2);
```

#### Step 3: Verify RTMR3 via Event Log

RTMR3 contains runtime information. Verify it by replaying the event log:

```rust
// Replay event log to calculate expected RTMR3
let calculated_rtmr3 = replay_event_log(&event_log);

// Verify RTMR3
assert_eq!(verified_mrs.rtmr3, calculated_rtmr3);

// Verify information in event log
let app_info = decode_app_info(&event_log)?;
assert_eq!(app_info.compose_hash, expected_compose_hash);
assert_eq!(app_info.os_image_hash, expected_os_image_hash);
```

## Guest Agent API

The Guest Agent exposes the following endpoints (on VM port 8090):

### GET /quote

Get TDX quote from the VM.

**Response**:
```json
{
  "quote": "base64_encoded_quote",
  "event_log": "base64_encoded_event_log"
}
```

### GET /health

Health check endpoint.

## Verification Library

The executor crate provides verification functions:

```rust
use platform_engine_executor::verify_vm_quote;

let is_valid = verify_vm_quote(&quote, &expected_measurements).await?;
```

## Security Considerations

- **Quote Freshness**: Always verify quotes are recent (prevent replay)
- **Measurement Validation**: Ensure measurements match expected values
- **Event Log Integrity**: Verify event log hasn't been tampered with
- **Key Verification**: Verify public keys match expected values

## See Also

- [Security](../docs/security.md) - Security architecture
- [Architecture](../docs/architecture.md) - System architecture
